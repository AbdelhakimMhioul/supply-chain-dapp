/**
 * @dev This script is designed to test the solidity smart contract - SupplyChain.sol -- and the various functions within
 */

// Import The SC Artifact
var SupplyChain = artifacts.require('SupplyChain');

// Variable for Product States
const State = {
   Harvested: 0,
   Processed: 1,
   Packed: 2,
   ForSale: 3,
   Sold: 4,
   Shipped: 5,
   Received: 6,
   Purchased: 7,
};

contract('SupplyChain', function (accounts) {
   // Declare few constants and assign a few sample accounts generated by ganache-cli
   let sku = 1;
   let upc = 1;
   const ownerID = accounts[0];
   const originFarmerID = accounts[1];
   const originFarmName = 'Abdelhakim Mhioul';
   const originFarmInformation = 'Yarray Valley';
   const originFarmLatitude = '-38.239770';
   const originFarmLongitude = '144.341490';
   let productID = sku + upc;
   const productNotes = 'Best Product';
   const productPrice = web3.utils.toWei('1', 'ether');
   const distributorID = accounts[2];
   const retailerID = accounts[3];
   const consumerID = accounts[4];

   console.log('ganache-cli accounts used here...');
   console.log('Contract Owner: accounts[0] ', accounts[0]);
   console.log('Farmer: accounts[1] ', accounts[1]);
   console.log('Distributor: accounts[2] ', accounts[2]);
   console.log('Retailer: accounts[3] ', accounts[3]);
   console.log('Consumer: accounts[4] ', accounts[4]);

   // 1st Test
   it('Testing smart contract function harvestItem() that allows a farmer to harvest product', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event Harvested()
      supplyChain.Harvested(() => eventEmitted = true)
      // Add the [1] account as a Farmer
      await supplyChain.addFarmer(originFarmerID, { from: ownerID });
      // Mark an item as Harvested by calling function harvestItem()
      await supplyChain.harvestItem(
         upc,
         originFarmerID,
         originFarmName,
         originFarmInformation,
         originFarmLatitude,
         originFarmLongitude,
         productNotes,
         { from: originFarmerID }
      );
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         originFarmerID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(
         item.itemState,
         State.Harvested,
         'Error: Invalid item State'
      );
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 2nd Test
   it('Testing smart contract function processItem() that allows a farmer to process product', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event Processed()
      supplyChain.Processed(() => eventEmitted = true)
      // Mark an item as Processed by calling function processtItem()
      await supplyChain.processItem(upc, { from: originFarmerID });
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         originFarmerID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(
         item.itemState,
         State.Processed,
         'Error: Invalid item State'
      );
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 3rd Test
   it('Testing smart contract function packItem() that allows a farmer to pack product', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event Packed()
      supplyChain.Packed(() => eventEmitted = true)
      // Mark an item as Packed by calling function packItem()
      await supplyChain.packItem(upc, { from: originFarmerID });
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         originFarmerID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(item.itemState, State.Packed, 'Error: Invalid item State');
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 4th Test
   it('Testing smart contract function sellItem() that allows a farmer to sell product', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event ForSale()
      supplyChain.ForSale(() => eventEmitted = true)
      // Mark an item as ForSale by calling function sellItem()
      await supplyChain.sellItem(upc, productPrice, { from: originFarmerID });
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         originFarmerID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(
         item.itemState,
         State.ForSale,
         'Error: Invalid item State'
      );
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 5th Test
   it('Testing smart contract function buyItem() that allows a distributor to buy product', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Add [2] address as a distributor
      await supplyChain.addDistributor(distributorID, { from: ownerID });
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event Sold()
      supplyChain.Sold(() => eventEmitted = true)
      // Mark an item as Sold by calling function buyItem()
      await supplyChain.buyItem(upc, {
         from: distributorID,
         value: productPrice,
      });
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         distributorID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(item.itemState, State.Sold, 'Error: Invalid item State');
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 6th Test
   it('Testing smart contract function shipItem() that allows a distributor to ship product', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event Shipped()
      supplyChain.Shipped(() => eventEmitted = true)
      // Mark an item as Shipped by calling function shipItem()
      await supplyChain.shipItem(upc, { from: distributorID });
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         distributorID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(
         item.itemState,
         State.Shipped,
         'Error: Invalid item State'
      );
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 7th Test
   it('Testing smart contract function receiveItem() that allows a retailer to mark product received', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event Received()
      supplyChain.Received(() => eventEmitted = true)
      // Add [3] accounts as a new retailer
      await supplyChain.addRetailer(retailerID, { from: ownerID });
      // Mark an item as Received by calling function receiveItem()
      await supplyChain.receiveItem(upc, { from: retailerID });
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         retailerID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(
         item.itemState,
         State.Received,
         'Error: Invalid item State'
      );
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(item.retailerID, retailerID, 'Error: Invalid Retailer ID');
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 8th Test
   it('Testing smart contract function purchaseItem() that allows a consumer to purchase product', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Declare and Initialize a variable for event
      let eventEmitted = false;
      // Watch the emitted event Purchased()
      supplyChain.Purchased(() => eventEmitted = true)
      // Add [4] account as a new consumer
      await supplyChain.addConsumer(consumerID, { from: ownerID });
      // Mark an item as Purchased by calling function purchaseItem()
      await supplyChain.purchaseItem(upc, {
         from: consumerID,
         value: productPrice,
      });
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         consumerID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(
         item.itemState,
         State.Purchased,
         'Error: Invalid item State'
      );
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
      assert.equal(item.retailerID, retailerID, 'Error: Invalid Retailer ID');
      assert.equal(item.consumerID, consumerID, 'Error: Invalid Consumer ID');
      assert.equal(eventEmitted, true, 'Invalid event emitted');
   });

   // 9th Test
   it('Testing smart contract function fetchItem() that allows anyone to fetch item details from blockchain', async () => {
      const supplyChain = await SupplyChain.deployed();
      // Retrieve the just now saved item from blockchain by calling function fetchItem()
      const item = await supplyChain.fetchItem.call(upc);
      // Verify the result set
      assert.equal(item.sku, sku, 'Error: Invalid item SKU');
      assert.equal(item.upc, upc, 'Error: Invalid item UPC');
      assert.equal(
         item.ownerID,
         consumerID,
         'Error: Missing or Invalid ownerID'
      );
      assert.equal(
         item.originFarmerID,
         originFarmerID,
         'Error: Missing or Invalid originFarmerID'
      );
      assert.equal(
         item.originFarmName,
         originFarmName,
         'Error: Missing or Invalid originFarmName'
      );
      assert.equal(
         item.originFarmInformation,
         originFarmInformation,
         'Error: Missing or Invalid originFarmInformation'
      );
      assert.equal(
         item.originFarmLatitude,
         originFarmLatitude,
         'Error: Missing or Invalid originFarmLatitude'
      );
      assert.equal(
         item.originFarmLongitude,
         originFarmLongitude,
         'Error: Missing or Invalid originFarmLongitude'
      );
      assert.equal(
         item.productID,
         productID,
         'Error: Invalid item State'
      );
   });
})